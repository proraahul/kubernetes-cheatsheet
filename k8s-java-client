now give you a COMPLETE, STEP-BY-STEP implementation for a company internal lab where:

‚úÖ Kubernetes master is on Linux

‚úÖ Spring Boot app runs on Windows / another server

‚úÖ HTTP is used not HTTPS

‚úÖ NO ca.crt

‚úÖ SSL verification disabled (acceptable for internal lab)

====


Got it üëç
Below is a **COMPLETE, PRACTICAL, STEP-BY-STEP implementation** specifically for a **company internal lab** where you **intentionally use HTTP (not HTTPS)** and **no CA cert**.

‚ö†Ô∏è **Important upfront truth**
Kubernetes **natively runs its API server on HTTPS (6443)**.
üëâ There is **NO official HTTP-only Kubernetes API**.

So when people say *‚Äúuse HTTP‚Äù* in internal labs, what they **actually do** is one of these:

1. **Expose Kubernetes API via an internal HTTP reverse proxy**
2. **Use kubectl proxy (HTTP)**
3. **Use SSH tunnel + HTTP**
4. **Use insecure kube-apiserver flags (NOT recommended even in lab)**

For **company internal lab**, the **BEST & SAFE approach** is:

> ‚úÖ **kubectl proxy (HTTP)**

This is **exactly meant for local / internal testing**.

---

# ‚úÖ FINAL APPROACH (RECOMMENDED)

```
Spring Boot App (Windows / Server)
        |
        |  HTTP (no SSL)
        |
kubectl proxy (Linux Master)
        |
        |  HTTPS (internal)
        |
Kubernetes API Server
```

Spring Boot **never talks to HTTPS**
üëâ It only talks to **HTTP**

---

# 1Ô∏è‚É£ PREREQUISITES

On **Linux Kubernetes master**:

* kubectl installed
* kubeconfig already working

Test:

```bash
kubectl get nodes
```

---

# 2Ô∏è‚É£ START KUBECTL PROXY (HTTP)

Run this on **Kubernetes master**:

```bash
kubectl proxy \
  --address='0.0.0.0' \
  --port=8001 \
  --accept-hosts='.*'
```

‚úÖ This exposes **HTTP API** on port **8001**

Test locally:

```bash
curl http://localhost:8001/api
```

---

# 3Ô∏è‚É£ FIREWALL (IMPORTANT)

Allow port **8001** on Kubernetes master:

```bash
sudo ufw allow 8001
```

or (CentOS/RHEL):

```bash
sudo firewall-cmd --add-port=8001/tcp --permanent
sudo firewall-cmd --reload
```

---

# 4Ô∏è‚É£ TEST FROM WINDOWS / OTHER SERVER

```bash
curl http://<MASTER_IP>:8001/api
```

If you get JSON ‚Üí ‚úÖ WORKING

---

# 5Ô∏è‚É£ SPRING BOOT DEPENDENCY

### `pom.xml`

```xml
<dependency>
    <groupId>io.kubernetes</groupId>
    <artifactId>client-java</artifactId>
    <version>20.0.1</version>
</dependency>
```

---

# 6Ô∏è‚É£ SPRING CONFIG (PURE HTTP, NO SSL, NO TOKEN)

### `KubernetesClientConfig.java`

```java
package com.example.k8s.config;

import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.util.Config;
import jakarta.annotation.PostConstruct;
import org.springframework.context.annotation.Configuration as SpringConfig;

@SpringConfig
public class KubernetesClientConfig {

    @PostConstruct
    public void init() throws Exception {

        String proxyUrl = "http://<MASTER_IP>:8001";

        ApiClient client = Config.fromUrl(proxyUrl);

        client.setReadTimeout(0);
        Configuration.setDefaultApiClient(client);
    }
}
```

‚úî No token
‚úî No SSL
‚úî No ca.crt
‚úî Pure HTTP

---

# 7Ô∏è‚É£ SERVICE ‚Äì LIST PODS

### `KubernetesService.java`

```java
package com.example.k8s.service;

import io.kubernetes.client.openapi.apis.CoreV1Api;
import io.kubernetes.client.openapi.models.V1Pod;
import org.springframework.stereotype.Service;

@Service
public class KubernetesService {

    private final CoreV1Api api = new CoreV1Api();

    public void listPods(String namespace) throws Exception {
        var pods = api.listNamespacedPod(
                namespace,
                null, null, null,
                null, null,
                null, null, null,
                null, null
        );

        for (V1Pod pod : pods.getItems()) {
            System.out.println("Pod: " + pod.getMetadata().getName());
        }
    }
}
```

---

# 8Ô∏è‚É£ CONTROLLER

### `K8sController.java`

```java
package com.example.k8s.controller;

import com.example.k8s.service.KubernetesService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/k8s")
public class K8sController {

    private final KubernetesService service;

    public K8sController(KubernetesService service) {
        this.service = service;
    }

    @GetMapping("/pods/{namespace}")
    public String pods(@PathVariable String namespace) throws Exception {
        service.listPods(namespace);
        return "Pods fetched";
    }
}
```

---

# 9Ô∏è‚É£ TEST ENDPOINT

From browser / Postman:

```
GET http://localhost:8080/k8s/pods/default
```

Logs:

```
Pod: nginx-xxx
Pod: redis-xxx
```

üéâ SUCCESS

---

# üîê WHY THIS WORKS WITHOUT SECURITY

* `kubectl proxy`:

  * Uses **your kubeconfig**
  * Authenticates internally
  * Exposes **safe HTTP endpoint**
* Spring Boot never sees certificates
* Ideal for **internal lab & testing**

---

# ‚ùå WHAT NOT TO DO

‚ùå Disable TLS in kube-apiserver
‚ùå Expose 6443 directly via HTTP
‚ùå Use `--insecure-port` (removed in new K8s)

---

# üß† WHEN TO USE THIS SETUP

‚úÖ Internal company lab
‚úÖ POC tools
‚úÖ Automation testing
‚úÖ Training environments

‚ùå Public network
‚ùå Production clusters

---

# üöÄ NEXT STEPS (OPTIONAL)

If you want, I can next show you how to:

1Ô∏è‚É£ Execute kubectl commands
2Ô∏è‚É£ Deploy YAML from Spring Boot
3Ô∏è‚É£ Scale deployments
4Ô∏è‚É£ Stream pod logs
5Ô∏è‚É£ Add basic auth on kubectl proxy

Just tell me üî•
