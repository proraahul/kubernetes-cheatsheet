now give you a COMPLETE, STEP-BY-STEP implementation for a company internal lab where:

‚úÖ Kubernetes master is on Linux

‚úÖ Spring Boot app runs on Windows / another server

‚úÖ HTTP is used not HTTPS

‚úÖ NO ca.crt

‚úÖ SSL verification disabled (acceptable for internal lab)

====


Got it üëç
Below is a **COMPLETE, PRACTICAL, STEP-BY-STEP implementation** specifically for a **company internal lab** where you **intentionally use HTTP (not HTTPS)** and **no CA cert**.

‚ö†Ô∏è **Important upfront truth**
Kubernetes **natively runs its API server on HTTPS (6443)**.
üëâ There is **NO official HTTP-only Kubernetes API**.

So when people say *‚Äúuse HTTP‚Äù* in internal labs, what they **actually do** is one of these:

1. **Expose Kubernetes API via an internal HTTP reverse proxy**
2. **Use kubectl proxy (HTTP)**
3. **Use SSH tunnel + HTTP**
4. **Use insecure kube-apiserver flags (NOT recommended even in lab)**

For **company internal lab**, the **BEST & SAFE approach** is:

> ‚úÖ **kubectl proxy (HTTP)**

This is **exactly meant for local / internal testing**.

---

# ‚úÖ FINAL APPROACH (RECOMMENDED)

```
Spring Boot App (Windows / Server)
        |
        |  HTTP (no SSL)
        |
kubectl proxy (Linux Master)
        |
        |  HTTPS (internal)
        |
Kubernetes API Server
```

Spring Boot **never talks to HTTPS**
üëâ It only talks to **HTTP**

---

# 1Ô∏è‚É£ PREREQUISITES

On **Linux Kubernetes master**:

* kubectl installed
* kubeconfig already working

Test:

```bash
kubectl get nodes
```

---

# 2Ô∏è‚É£ START KUBECTL PROXY (HTTP)

Run this on **Kubernetes master**:

```bash
kubectl proxy \
  --address='0.0.0.0' \
  --port=8001 \
  --accept-hosts='.*'
```

‚úÖ This exposes **HTTP API** on port **8001**

Test locally:

```bash
curl http://localhost:8001/api
```

---

# 3Ô∏è‚É£ FIREWALL (IMPORTANT)

Allow port **8001** on Kubernetes master:

```bash
sudo ufw allow 8001
```

or (CentOS/RHEL):

```bash
sudo firewall-cmd --add-port=8001/tcp --permanent
sudo firewall-cmd --reload
```

---

# 4Ô∏è‚É£ TEST FROM WINDOWS / OTHER SERVER

```bash
curl http://<MASTER_IP>:8001/api
```

If you get JSON ‚Üí ‚úÖ WORKING

---

# 5Ô∏è‚É£ SPRING BOOT DEPENDENCY

### `pom.xml`

```xml
<dependency>
    <groupId>io.kubernetes</groupId>
    <artifactId>client-java</artifactId>
    <version>20.0.1</version>
</dependency>
```

---

# 6Ô∏è‚É£ SPRING CONFIG (PURE HTTP, NO SSL, NO TOKEN)

### `KubernetesClientConfig.java`

```java
package com.example.k8s.config;

import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.util.Config;
import jakarta.annotation.PostConstruct;
import org.springframework.context.annotation.Configuration as SpringConfig;

@SpringConfig
public class KubernetesClientConfig {

    @PostConstruct
    public void init() throws Exception {

        String proxyUrl = "http://<MASTER_IP>:8001";

        ApiClient client = Config.fromUrl(proxyUrl);

        client.setReadTimeout(0);
        Configuration.setDefaultApiClient(client);
    }
}
```

‚úî No token
‚úî No SSL
‚úî No ca.crt
‚úî Pure HTTP

---

# 7Ô∏è‚É£ SERVICE ‚Äì LIST PODS

### `KubernetesService.java`

```java
package com.example.k8s.service;

import io.kubernetes.client.openapi.apis.CoreV1Api;
import io.kubernetes.client.openapi.models.V1Pod;
import org.springframework.stereotype.Service;

@Service
public class KubernetesService {

    private final CoreV1Api api = new CoreV1Api();

    public void listPods(String namespace) throws Exception {
        var pods = api.listNamespacedPod(
                namespace,
                null, null, null,
                null, null,
                null, null, null,
                null, null
        );

        for (V1Pod pod : pods.getItems()) {
            System.out.println("Pod: " + pod.getMetadata().getName());
        }
    }
}
```

---

# 8Ô∏è‚É£ CONTROLLER

### `K8sController.java`

```java
package com.example.k8s.controller;

import com.example.k8s.service.KubernetesService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/k8s")
public class K8sController {

    private final KubernetesService service;

    public K8sController(KubernetesService service) {
        this.service = service;
    }

    @GetMapping("/pods/{namespace}")
    public String pods(@PathVariable String namespace) throws Exception {
        service.listPods(namespace);
        return "Pods fetched";
    }
}
```

---

# 9Ô∏è‚É£ TEST ENDPOINT

From browser / Postman:

```
GET http://localhost:8080/k8s/pods/default
```

Logs:

```
Pod: nginx-xxx
Pod: redis-xxx
```

üéâ SUCCESS

---

# üîê WHY THIS WORKS WITHOUT SECURITY

* `kubectl proxy`:

  * Uses **your kubeconfig**
  * Authenticates internally
  * Exposes **safe HTTP endpoint**
* Spring Boot never sees certificates
* Ideal for **internal lab & testing**

---

# ‚ùå WHAT NOT TO DO

‚ùå Disable TLS in kube-apiserver
‚ùå Expose 6443 directly via HTTP
‚ùå Use `--insecure-port` (removed in new K8s)

---

# üß† WHEN TO USE THIS SETUP

‚úÖ Internal company lab
‚úÖ POC tools
‚úÖ Automation testing
‚úÖ Training environments

‚ùå Public network
‚ùå Production clusters

---

# üöÄ NEXT STEPS (OPTIONAL)

If you want, I can next show you how to:

1Ô∏è‚É£ Execute kubectl commands
2Ô∏è‚É£ Deploy YAML from Spring Boot
3Ô∏è‚É£ Scale deployments
4Ô∏è‚É£ Stream pod logs
5Ô∏è‚É£ Add basic auth on kubectl proxy

Just tell me üî•


=======




Excellent question üëå
This is **exactly how real companies design it** ‚Äî *one codebase*, **switch lab ‚Üí production by config only**.

Below is a **PRODUCTION-READY, SWITCHABLE DESIGN** where:

* ‚úÖ Internal lab ‚Üí **HTTP + no cert**
* ‚úÖ Production ‚Üí **HTTPS + ca.crt**
* ‚úÖ **NO code change**
* ‚úÖ Only **config switch**

---

# üèóÔ∏è FINAL ARCHITECTURE (CONFIG-DRIVEN)

```
Spring Boot Application
        |
        |  (config based)
        |
        +-- LAB      ‚Üí HTTP  (kubectl proxy)
        |
        +-- PROD     ‚Üí HTTPS (K8s API + ca.crt)
```

---

# 1Ô∏è‚É£ CREATE A SINGLE CONFIG MODEL

### `KubernetesProperties.java`

```java
package com.example.k8s.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Data
@Configuration
@ConfigurationProperties(prefix = "k8s")
public class KubernetesProperties {

    private String mode;          // lab | prod
    private String masterUrl;
    private String token;
    private String caCertPath;    // only prod
}
```

---

# 2Ô∏è‚É£ SINGLE CLIENT CONFIG (AUTO SWITCH)

### `KubernetesClientConfig.java`

```java
package com.example.k8s.config;

import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.util.Config;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration as SpringConfig;

import java.io.FileReader;

@SpringConfig
@RequiredArgsConstructor
public class KubernetesClientConfig {

    private final KubernetesProperties props;

    @PostConstruct
    public void init() throws Exception {

        ApiClient client;

        if ("lab".equalsIgnoreCase(props.getMode())) {

            // üî¥ LAB MODE (HTTP)
            client = Config.fromUrl(props.getMasterUrl());

        } else {

            // üü¢ PROD MODE (HTTPS + CA)
            client = Config.fromToken(
                    props.getMasterUrl(),
                    props.getToken(),
                    false
            );

            client.setSslCaCert(new FileReader(props.getCaCertPath()));
        }

        client.setReadTimeout(0);
        Configuration.setDefaultApiClient(client);
    }
}
```

‚úî One class
‚úî One codebase
‚úî Environment-driven

---

# 3Ô∏è‚É£ LAB CONFIG (HTTP)

### `application-lab.yml`

```yaml
k8s:
  mode: lab
  master-url: http://10.10.1.20:8001   # kubectl proxy
```

Run:

```bash
kubectl proxy --address=0.0.0.0 --port=8001 --accept-hosts='.*'
```

Start app:

```bash
java -jar app.jar --spring.profiles.active=lab
```

---

# 4Ô∏è‚É£ PROD CONFIG (HTTPS)

### `application-prod.yml`

```yaml
k8s:
  mode: prod
  master-url: https://10.10.1.20:6443
  token: ${K8S_TOKEN}
  ca-cert-path: /etc/k8s/ca.crt
```

Start app:

```bash
export K8S_TOKEN=xxxxxx
java -jar app.jar --spring.profiles.active=prod
```

---

# 5Ô∏è‚É£ SERVICE & CONTROLLER (UNCHANGED)

```java
CoreV1Api api = new CoreV1Api();
```

üéØ Zero changes between lab & prod

---

# 6Ô∏è‚É£ WHY THIS IS ENTERPRISE-GRADE

| Feature       | Lab           | Prod           |
| ------------- | ------------- | -------------- |
| Protocol      | HTTP          | HTTPS          |
| Auth          | kubectl proxy | ServiceAccount |
| SSL           | Disabled      | Enabled        |
| Code change   | ‚ùå             | ‚ùå              |
| Config change | ‚úÖ             | ‚úÖ              |

---

# 7Ô∏è‚É£ SECURITY NOTES

* **Lab**

  * Private network only
  * Firewall port 8001
* **Prod**

  * RBAC restricted
  * Token in Vault / Env
  * CA cert mandatory

---

# 8Ô∏è‚É£ QUICK FLOW CHECK

| Action      | Lab | Prod |
| ----------- | --- | ---- |
| List pods   | ‚úÖ   | ‚úÖ    |
| Deploy YAML | ‚úÖ   | ‚úÖ    |
| Scale pods  | ‚úÖ   | ‚úÖ    |
| Logs        | ‚úÖ   | ‚úÖ    |

---

# üîÅ HOW TO MIGRATE LAB ‚Üí PROD (REALISTIC)

1Ô∏è‚É£ Add CA cert
2Ô∏è‚É£ Create ServiceAccount
3Ô∏è‚É£ Switch profile
4Ô∏è‚É£ Restart app

‚è± Takes **5 minutes**, not days

---

# üß† FINAL VERDICT

‚úî This is **exactly how internal platforms are built**
‚úî Same binary for all environments
‚úî Safe, clean, scalable

---

If you want next:

* üîê Namespace-only RBAC
* üì¶ Deploy YAML from Java
* üìú Run kubectl commands
* üìä Metrics API
* üîÅ Watch pods in real-time

Just tell me üöÄ

